import e from"seamless-immutable";const r={EMPTY:" is null or empty.",NULL:" is null.",UNDEFINED:" is undefined.",validateInRange(e,r,t,a){if(this.validateIsNumber(e,r),r<t||a<r)throw console.error((new Error).stack),new Error(`${e} is out of range [${t}, ${a}]: ${r}`)},validateIsArray(e,r){if(!Array.isArray(r))throw console.error((new Error).stack),new Error(`${e} is not an array: ${r}`)},validateIsBoolean(e,r){if("boolean"!=typeof r)throw console.error((new Error).stack),new Error(`${e} is not a boolean: ${r}`)},validateIsFunction(e,r){if("function"!=typeof r)throw console.error((new Error).stack),new Error(`${e} is not a function: ${r}`)},validateIsNumber(e,r){if("number"!=typeof r)throw console.error((new Error).stack),new Error(`${e} is not a number: ${r}`)},validateIsString(e,r){if("string"!=typeof r)throw console.error((new Error).stack),new Error(`${e} is not a string: ${r}`)},validateNotEmpty(e,t){if(Array.isArray(t)){if(0===t.length)throw console.error((new Error).stack),new Error(e+r.EMPTY)}else if(!Number.isNaN(parseFloat(t))&&Number.isFinite(t));else if(!0===t||!1===t);else if(!t)throw console.error((new Error).stack),new Error(e+r.EMPTY)},validateNotIncludesNil(e,r){this.validateNotNil(e,r),this.validateIsArray(e,r),r.forEach((r=>{this.validateNotNil(`${e} element`,r)}))},validateNotNil(e,t){if(void 0===t)throw console.error((new Error).stack),new Error(e+r.UNDEFINED);if(null===t)throw console.error((new Error).stack),new Error(e+r.NULL)}},t={create:({amount:e=1,resourceKey:t,clientProps:a={}})=>(r.validateIsString("resourceKey",t),Immutable({amount:e,resourceKey:t,clientProps:a}))};Object.freeze(t);const a={create:({inputs:e,key:t,name:a,outputs:o,clientProps:i={}})=>{r.validateIsArray("inputs",e),r.validateIsString("name",a),r.validateIsArray("outputs",o);return Immutable({inputs:e,key:t||a,name:a,outputs:o,clientProps:i})}};Object.freeze(a);const o={create:({image:t,key:a,name:o,value:i=0,clientProps:n={}})=>{r.validateIsString("name",o);return e({image:t,key:a||o,name:o,value:i,clientProps:n})}};Object.freeze(o);const i={};i.toString=(e,t)=>{if(r.validateNotNil("ingredientData",e),r.validateNotNil("resolver",t),Array.isArray(e))return((e,r)=>{const t=R.reduce(((e,t)=>`${e}${i.toString(t,r)} + `),"",e);return t.substring(0,t.length-" + ".length)})(e,t);const{amount:a,resourceKey:o}=e,n=t.resourceData(o);return R.isNil(n)||R.isNil(a)?null:`${n.name} x${a}`},i.value=(e,t)=>{if(r.validateNotNil("ingredientData",e),r.validateNotNil("resolver",t),Array.isArray(e))return((e,r)=>R.reduce(((e,t)=>e+i.value(t,r)),0,e))(e,t);const{amount:a,resourceKey:o}=e,n=t.resourceData(o),l=R.isNil(n)?0:n.value;return R.isNil(l)||R.isNil(a)?null:l*a};const n={accept:(e,r)=>r.visit(e),findByOutput:(e,t)=>{r.validateIsString("resourceKey",e),r.validateNotNil("resolver",t);const a=r=>r.resourceKey===e;return R.reduce(((e,r)=>R.filter(a,r.outputs).length>0?R.append(r,e):e),[],t.recipeValues())},inputValue:(e,t)=>{r.validateNotNil("recipeData",e),r.validateNotNil("resolver",t);return R.reduce(((e,r)=>{const a=i.value(r,t);return a?e+a:e}),0,e.inputs)},outputInputRatio:(e,t)=>{r.validateNotNil("recipeData",e),r.validateNotNil("resolver",t);const a=n.outputValue(e,t),o=n.inputValue(e,t);return a&&o?a/o:null},outputValue:(e,t)=>{r.validateNotNil("recipeData",e),r.validateNotNil("resolver",t);return R.reduce(((e,r)=>{const a=i.value(r,t);return a?e+a:e}),0,e.outputs)},toString:(e,t,a)=>{r.validateNotNil("recipeData",e),r.validateNotNil("resolver",t);const{inputs:o,name:n,outputs:l}=e;return`${a&&n?`${n}: `:""}${i.toString(l,t)} ← ${i.toString(o,t)}`}},l={toString:e=>(r.validateNotNil("resourceData",e),e.name)};class s{}s.InputValidator=r,s.IngredientData=t,s.RecipeData=a,s.ResourceData=o,s.IngredientFunction=i,s.RecipeFunction=n,s.ResourceFunction=l;export{s as default};
