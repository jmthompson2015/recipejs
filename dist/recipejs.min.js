import e from"seamless-immutable";const r={EMPTY:" is null or empty.",NULL:" is null.",UNDEFINED:" is undefined.",validateInRange(e,r,t,o){if(this.validateIsNumber(e,r),r<t||o<r)throw console.error((new Error).stack),new Error(`${e} is out of range [${t}, ${o}]: ${r}`)},validateIsArray(e,r){if(!Array.isArray(r))throw console.error((new Error).stack),new Error(`${e} is not an array: ${r}`)},validateIsBoolean(e,r){if("boolean"!=typeof r)throw console.error((new Error).stack),new Error(`${e} is not a boolean: ${r}`)},validateIsFunction(e,r){if("function"!=typeof r)throw console.error((new Error).stack),new Error(`${e} is not a function: ${r}`)},validateIsNumber(e,r){if("number"!=typeof r)throw console.error((new Error).stack),new Error(`${e} is not a number: ${r}`)},validateIsString(e,r){if("string"!=typeof r)throw console.error((new Error).stack),new Error(`${e} is not a string: ${r}`)},validateNotEmpty(e,t){if(Array.isArray(t)){if(0===t.length)throw console.error((new Error).stack),new Error(e+r.EMPTY)}else if(!Number.isNaN(parseFloat(t))&&Number.isFinite(t));else if(!0===t||!1===t);else if(!t)throw console.error((new Error).stack),new Error(e+r.EMPTY)},validateNotIncludesNil(e,r){this.validateNotNil(e,r),this.validateIsArray(e,r),r.forEach((r=>{this.validateNotNil(`${e} element`,r)}))},validateNotNil(e,t){if(void 0===t)throw console.error((new Error).stack),new Error(e+r.UNDEFINED);if(null===t)throw console.error((new Error).stack),new Error(e+r.NULL)}},t={create:({amount:t=1,resourceKey:o,clientProps:a={}})=>(r.validateIsString("resourceKey",o),e({amount:t,resourceKey:o,clientProps:a}))};Object.freeze(t);const o={create:({inputs:t,fabricators:o,key:a,name:i,outputs:n,clientProps:s={}})=>{r.validateIsArray("inputs",t),r.validateIsArray("outputs",n);return e({inputs:t,fabricators:o,key:a||i,name:i,outputs:n,clientProps:s})}};Object.freeze(o);const a={create:({image:t,key:o,name:a,value:i=0,clientProps:n={}})=>{r.validateIsString("name",a);return e({image:t,key:o||a,name:a,value:i,clientProps:n})}};Object.freeze(a);const i={};i.toString=(e,t)=>{if(r.validateNotNil("ingredientData",e),r.validateNotNil("resolver",t),Array.isArray(e))return((e,r)=>{const t=R.reduce(((e,t)=>`${e}${i.toString(t,r)} + `),"",e);return t.substring(0,t.length-" + ".length)})(e,t);const{amount:o,resourceKey:a}=e,n=t.resourceData(a);return R.isNil(n)||R.isNil(o)?null:`${n.name} x${o}`},i.value=(e,t)=>{if(r.validateNotNil("ingredientData",e),r.validateNotNil("resolver",t),Array.isArray(e))return((e,r)=>R.reduce(((e,t)=>e+i.value(t,r)),0,e))(e,t);const{amount:o,resourceKey:a}=e,n=t.resourceData(a),s=R.isNil(n)?0:n.value;return R.isNil(s)||R.isNil(o)?null:s*o};const n={accept:(e,r)=>r.visit(e),findByOutput:(e,t)=>{r.validateIsString("resourceKey",e),r.validateNotNil("resolver",t);const o=r=>r.resourceKey===e;return R.reduce(((e,r)=>R.filter(o,r.outputs).length>0?R.append(r,e):e),[],t.recipeValues())},inputValue:(e,t)=>{r.validateNotNil("recipeData",e),r.validateNotNil("resolver",t);return R.reduce(((e,r)=>{const o=i.value(r,t);return o?e+o:e}),0,e.inputs)},outputInputRatio:(e,t)=>{r.validateNotNil("recipeData",e),r.validateNotNil("resolver",t);const o=n.outputValue(e,t),a=n.inputValue(e,t);return o&&a?o/a:null},outputValue:(e,t)=>{r.validateNotNil("recipeData",e),r.validateNotNil("resolver",t);return R.reduce(((e,r)=>{const o=i.value(r,t);return o?e+o:e}),0,e.outputs)},toString:(e,t,o)=>{r.validateNotNil("recipeData",e),r.validateNotNil("resolver",t);const{inputs:a,name:n,outputs:s}=e;return`${o&&n?`${n}: `:""}${i.toString(s,t)} ← ${i.toString(a,t)}`}},s={toString:e=>(r.validateNotNil("resourceData",e),e.name)};class l{}l.InputValidator=r,l.IngredientData=t,l.RecipeData=o,l.ResourceData=a,l.IngredientFunction=i,l.RecipeFunction=n,l.ResourceFunction=s;export{l as default};
